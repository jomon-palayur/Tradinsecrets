import fs from "node:fs/promises"
import path from "node:path"
import merge from "deepmerge"

import config from "../config/index.js"

import getURL from "../utils/get-url.js"
import slugify from "../utils/slugify.js"
import { warn, fail } from "../utils/logger.js"
import { exists } from "../utils/fs.js"

import { getLayout, applyLayout } from "./layout.js"
import { parseIndex, parseData } from "./parse.js"

const getMeta = (src, url) => {
  let dist = path.join(config.dist, path.normalize(url))

  if (path.extname(dist) === "") {
    dist = path.join(dist, "index.html")
  }

  return {
    url,
    src,
    dist,
  }
}

const getDirectoryLayout = async (filename) => {
  const segments = path
    .relative(config.src, path.dirname(filename))
    .split(path.sep)

  segments.unshift("")

  while (segments.length) {
    const dir = path.join(...segments, "_layout.pug")
    if (await exists(path.join(config.src, dir))) return dir
    segments.pop()
  }
}

export default async (filename, hasChanged) => {
  try {
    const timestamp = Date.now()
    const contents = await fs.readFile(filename, "utf8")

    if (hasChanged && !hasChanged(filename, contents)) return

    let template

    for (const ext in config.compilers) {
      if (filename.endsWith(ext)) {
        template = await config.compilers[ext](filename, contents)

        const rel = path.relative(config.src, filename)
        const alt = rel.slice(0, -ext.length) + template.ext

        template.data.url ??= getURL(
          alt,
          config.trailingSlash,
          config.stripSortPrefix
        )
        break
      }
    }

    if (!template) {
      throw Error(`No compiler was found for ${filename}`)
    }

    parseData(template.data, filename)

    const meta = getMeta(filename, template.data.url)

    // See if there is a directory layout or global layout available
    if (
      meta.dist.endsWith(".html") &&
      !Object.hasOwn(template.data, "layout")
    ) {
      const directoryLayout = await getDirectoryLayout(filename)

      if (directoryLayout) {
        template.data.layout ??= directoryLayout
      }

      if (config.globals?.layout) {
        template.data.layout ??= config.globals.layout
      }
    }

    // Unmodified data for when template and index have a layout
    const baseTemplate = { ...template }

    // Overide template with layout
    if (template.data.layout) {
      const layout = await getLayout(template.data.layout, filename)
      applyLayout(template, layout)
    }

    // If global data is available, the template data should extend it
    if (config.globals) {
      template.data = merge(config.globals, template.data)
    }

    // This page indexes other pages
    if (template.data.index) {
      let { render, data } = template

      // Override the base template with the layout
      if (template.data.index.layout) {
        const layout = await getLayout(template.data.index.layout, filename)

        applyLayout(baseTemplate, layout)

        template.dependencies.push(...baseTemplate.dependencies)
        render = baseTemplate.render
        data = baseTemplate.data

        if (config.globals) data = merge(config.globals, data)
      }

      template.index = {
        ...parseIndex(template.data.index, filename),
        data,
        render,
        meta,
      }

      // Don't render any pages for this template if pages isn't set
      template.data.pages ??= []
    }

    if (Array.isArray(template.data.pages)) {
      const parentMeta = meta

      template.pages = template.data.pages.map((item, i) => {
        const slug = (item.slug ?? slugify(item.title || i + 1)).toString()

        const url =
          item.url ??
          getURL(
            path.join(parentMeta.url, slug),
            config.trailingSlash,
            config.stripSortPrefix
          )

        const meta = getMeta(parentMeta.src, url)

        // If the page has a valid render function, capture it.
        const render =
          typeof item.render === "function" ? item.render : template.render

        // Child pages extend the template's data, but there is no need
        // to copy the `pages` property down to the child.
        const data = merge(template.data, item)
        delete data.pages

        if (item.layout) {
          warn(
            `Ignoring layout "${item.layout}" in ${filename}`,
            `Page items cannot specify custom layouts`
          )
        }

        return {
          render,
          meta,
          data,
        }
      })
    } else {
      template.pages = [
        {
          meta,
          render: template.render,
          data: template.data,
        },
      ]
    }

    // Remove hidden pages
    if (config.excludeHidden) {
      template.pages = template.pages.filter((page) => !page.data.hide)
    }

    delete template.data
    delete template.render

    template.pages.forEach((item) => {
      delete item.data.render

      if (item.data.date) {
        const date = new Date(item.data.date)
        if (Number.isInteger(+date)) item.data.date = date
        else warn(`Invalid date format "${item.data.date}" in ${filename}`)
      }
    })

    if (Date.now() - timestamp > 100) {
      warn(`${filename} took ${Date.now() - timestamp}ms to compile`)
    }

    return template
  } catch (err) {
    fail(`Failed to compile ${filename}`, err)
  }
}
