import fs from "node:fs/promises"
import path from "node:path"
import merge from "deepmerge"

import config from "../config/index.js"
import Cache from "../utils/cache.js"
import { exists } from "../utils/fs.js"
import { parseData } from "./parse.js"

// Some templates specify a Pug layout file.
// Compiling layouts is expensive, so they are only compiled when
// they (or one of their dependencies) changes.
export const layoutCache = new Cache()

export const resetLayoutDependencies = (filename) => {
  layoutCache.delete(filename)

  for (const layout of layoutCache.values()) {
    if (layout.dependencies.includes(filename)) {
      layoutCache.delete(layout.filename)
    }
  }
}

export const getLayout = async (layoutName, filename, depth = 0) => {
  let layout
  let basedir = config.src

  if (path.extname(layoutName) === "") {
    layoutName += ".pug"
  }

  if (config.compilers.pug?.options?.basedir) {
    basedir = config.compilers.pug.options.basedir
  }

  // Resolve layout paths relative to template
  if (layoutName.startsWith(".")) {
    layoutName = path.join(path.dirname(filename), layoutName)
  } else {
    layoutName = path.join(basedir, layoutName)
  }

  if (!(await exists(layoutName))) {
    throw Error(`Layout ${layoutName} does not exist`)
  }

  const content = await fs.readFile(layoutName, "utf8")

  // Only use the cached layout if its data is unchanged.
  if (!layoutCache.changed(layoutName, { content })) {
    layout = layoutCache.get(layoutName)
  }

  if (!layout) {
    for (const ext in config.compilers) {
      if (layoutName.endsWith(ext)) {
        layout = await config.compilers[ext](layoutName, content)
        break
      }
    }

    parseData(layout.data, layoutName)

    if (layout.data.layout && depth < config.maxLayoutDepth) {
      const parent = await getLayout(layout.data.layout, layoutName, depth++)
      applyLayout(layout, parent)
    }

    layoutCache.set(layoutName, layout)
  }

  return layout
}

export const applyLayout = (child, parent) => {
  // Merge the data
  child.data = merge(parent.data, child.data)

  // Add the parent and it's dependencies to the child
  child.dependencies ??= []
  child.dependencies.push(parent.filename, ...parent.dependencies)

  // If a template has a render method, the layout should wrap it
  if (child.render) {
    const inner = child.render
    const outer = parent.render

    child.render = (data) => outer({ ...data, content: inner(data) })
  } else {
    child.render = parent.render
  }
}
