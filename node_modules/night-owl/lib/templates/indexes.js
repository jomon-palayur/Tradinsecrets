import path from "node:path"
import minimatch from "minimatch"

import { warn } from "../utils/logger.js"
import getUrl from "../utils/get-url.js"
import chunk from "../utils/chunk.js"

const getIndexItems = (index, collections) => {
  const list = []

  if (index.list) {
    list.push(...index.list)
  }

  if (index.tags) {
    list.push(...index.tags.map((tag) => collections[tag] || []).flat())
  }

  if (index.glob) {
    list.push(
      ...collections.all.filter((item) => minimatch(item.meta.url, index.glob))
    )
  }

  if (index.filter) {
    return list.filter(index.filter)
  } else {
    return list
  }
}

const createIndexPage = (items, i, index) => {
  let url

  if (typeof index.slug === "function") {
    url = index.slug(index.meta.url, i)
  } else if (i === 0) {
    url = index.meta.url
  } else {
    url = getUrl(path.join(index.meta.url, index.slug, i.toString()))
  }

  const slug = path.relative(index.meta.url, url)
  const base = path.dirname(index.meta.dist)
  const dist = path.join(base, slug, "index.html")

  return {
    render: index.render,
    data: index.data,
    meta: {
      src: index.meta.src,
      dist,
      url,
      index: { items },
    },
  }
}

export default (indexes, allPages, collections) =>
  indexes.forEach((index) => {
    const items = getIndexItems(index, collections)

    if (items.length === 0) {
      warn(`${index.meta.src} created an empty index`)
    }

    let prev = undefined
    const pages = []

    chunk(items, index.size).forEach((items) => {
      const i = pages.length
      const next = createIndexPage(items, i, index)
      const meta = {
        src: next.meta.src,
        dist: next.meta.dist,
        url: next.meta.url,
      }

      if (i > 0) prev.meta.index.next = meta

      next.meta.index.page = i
      next.meta.index.pages = pages
      next.meta.index.prev = pages[i - 1]

      prev = next
      pages.push(meta)
      allPages.set(next.meta.dist, next)
    })
  })
