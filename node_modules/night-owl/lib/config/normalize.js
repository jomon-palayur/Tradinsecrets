import path from "node:path"

import minimatch from "minimatch"
import deepmerge from "deepmerge"

import { warn } from "../utils/logger.js"
import { getFileDependencies } from "../utils/get-dependencies.js"

import defaults from "./defaults.js"
import { exists } from "../utils/fs.js"

import { wrapCompiler, defaultCompilers } from "../compilers/index.js"

const isObject = (o) => {
  return Object.prototype.toString.call(o) === "[object Object]"
}

const isPlainObject = (object) => {
  if (!isObject(object)) return false

  const ctor = object.constructor
  if (ctor === undefined) return true

  const prot = ctor.prototype
  if (!isObject(prot)) return false

  if (!prot.hasOwnProperty("isPrototypeOf")) return false

  return true
}

const normalizeTransforms = (transforms, configTransforms) => {
  if (transforms === true) {
    transforms = configTransforms
  }

  if (typeof transforms === "function") {
    transforms = [transforms]
  }

  if (!Array.isArray(transforms)) {
    return []
  } else {
    return transforms.filter((transform) => typeof transform === "function")
  }
}

const normalizeCompilers = (compilers = {}) => {
  const result = {}

  const addCompiler = (type, compiler) => {
    if (!compiler) return

    // Use the default compiler when one isn't set
    const compile =
      typeof compiler.compile === "function"
        ? compiler.compile
        : defaultCompilers[type]

    if (compile) {
      // Ensure extensions are valid
      if (!Array.isArray(compiler.ext)) {
        compiler.ext = [
          typeof compiler.ext === "string" ? compiler.ext : `.${type}`,
        ]
      } else {
        compiler.ext = compiler.ext.filter((ext) => typeof ext === "string")
      }

      const fn = wrapCompiler(compile, compiler.options)
      compiler.ext.forEach((ext) => {
        result[ext] = fn
      })
    } else {
      warn(
        `No compiler is available for ${type}`,
        `If you want to add a new compiler, add a compile function`
      )
    }
  }

  // Add any template type functions from the user config
  // Remove any that are specifically set to false
  Object.entries(compilers).forEach(([type, compiler]) => {
    addCompiler(type, compiler)
  })

  return result
}

const isTemplate = ({ include, exclude } = {}, extensions) => {
  // Ignore empty or invalid rules
  if (!Array.isArray(exclude) || exclude.length === 0) exclude = false
  if (!Array.isArray(include) || include.length === 0) include = false

  return (filename) =>
    (!exclude || !exclude.some((rule) => minimatch(filename, rule))) &&
    (!include || include.some((rule) => minimatch(filename, rule))) &&
    extensions.some((ext) => filename.endsWith(ext))
}

export const normalizeConfig = async (userConfig, configFile) => {
  const config = deepmerge(defaults, userConfig || {}, {
    isMergeableObject: isPlainObject,
    customMerge: (key) => {
      if (key === "ext") return (a, b) => b
    },
  })

  // Check that src and dist are not the same directory
  if (path.resolve(config.src) === path.resolve(config.dist)) {
    config.dist = "_" + path.relative(process.cwd(), config.src)
    warn(
      `The same directory is used for \`src\` and \`dist\``,
      `Writing files to "${config.dist}" instead`
    )
  }

  // Watch the source directory
  config.watch.push(config.src)

  // Set up default compilers
  config.compilers = normalizeCompilers(config.compilers)

  // Set up template matcher
  config.isTemplate = isTemplate(
    config.templates,
    Object.keys(config.compilers)
  )

  // Watch the config file and its dependencies
  if (configFile) {
    config.watchAndRestart.push(configFile)

    if (await exists(configFile)) {
      config.watchAndRestart.push(...getFileDependencies(configFile))
    }
  }

  // Watch the data file and its dependencies
  if (config.data) {
    config.watchAndRestart.push(config.data)

    if (await exists(config.data)) {
      config.globals = (
        await import(path.join(process.cwd(), config.data))
      ).default

      config.watchAndRestart.push(...getFileDependencies(config.data))
    } else {
      warn(`Global data file ${config.data} was not found`)
    }
  }

  if (config.globals?.meta) {
    warn(
      `Global data includes \`meta\` data`,
      `This will be overwritten by Night Owl`
    )
    delete config.globals?.meta
  }

  config.transform = normalizeTransforms(true, config.transform)

  config.copy = config.copy
    .filter((rule) => rule && rule.src)
    .map((rule) => ({
      dist: config.dist,
      ...rule,
      transform: normalizeTransforms(rule.transform, config.transform),
    }))

  config.watch.push(...config.copy.map((rule) => rule.src))

  return config
}
