#!/usr/bin/env node
import { isMainThread } from "node:worker_threads"
import { setup } from "./config/index.js"

import build from "./build/index.js"
import watch from "./watch/index.js"
import serve from "./serve/index.js"

import { createWorker, beforeClose } from "./watch/worker.js"

const willBuild = process.argv.includes("--build")
const willWatch = process.argv.includes("--watch")
const willServe = process.argv.includes("--serve")

if (!willBuild && !willServe && !willBuild) {
  console.log(
    "\nUse one or more commands to run Night Owl...\n",
    `\nRun the build command with "night-owl --build"`,
    `\nRun the watch command with "night-owl --watch"`,
    `\nRun the serve command with "night-owl --serve"`,
    "\n"
  )
}

if (isMainThread) {
  // The build process doesn't require a worker, as the imports won't
  // change during the build process, so it can be run in the main thread.
  if (willBuild && !willWatch) {
    process.env.NIGHTOWL_MODE = "build"
    setup().then(build)
  } else {
    process.env.NIGHTOWL_MODE = "watch"
  }

  // Watch and serve do run in a worker. A new thread is created each time
  // a JavaScript dependency changes, to avoid importing stale cache items.
  if (willServe || willWatch) {
    createWorker(new URL(import.meta.url))
  }
} else {
  // Within the worker context, start the serve and watch processes.
  // When the worker is closed, ensure both are shut down gracefully.
  setup().then(async () => {
    const serveProcess = willServe ? await serve() : null
    const watchProcess = willWatch ? await watch(serveProcess) : null

    beforeClose(async () => {
      await serveProcess?.close()
      await watchProcess?.close()
    })
  })
}
