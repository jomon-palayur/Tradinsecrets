import fs from "node:fs/promises"
import { createReadStream } from "node:fs"
import path from "node:path"
import http from "node:http"
import stream from "node:stream"

import WebSocket, { WebSocketServer } from "ws"
import mime from "mime-types"

import config from "../config/index.js"
import { info, fail, warn } from "../utils/logger.js"
import { exists } from "../utils/fs.js"

import { appendClient, errorPage, clientURL, client } from "./assets.js"

const PORT_RETRY_LIMIT = 20

async function handle(res, filename) {
  if (filename.endsWith(".html")) {
    const html = appendClient(await fs.readFile(filename, "utf8"))

    res.writeHead(200, {
      "Content-Type": "text/html",
      "Cache-Control": "no-cache, no-store, must-revalidate",
    })

    res.end(html)
  } else {
    res.writeHead(200, {
      "Content-Length": (await fs.stat(filename)).size,
      "Content-Type": mime.contentType(path.basename(filename)),
      "Cache-Control": "no-cache, no-store, must-revalidate",
    })

    stream.pipeline(createReadStream(filename), res, (err) => {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        console.error(err)
      }
    })
  }
}

export default () => {
  let port = config.port
  let host = config.host
  let wss

  const server = http.createServer(async (req, res) => {
    let filename = decodeURIComponent(
      req.url.slice(1).match(/.*?(?=[#?]|$)/) ?? ""
    )


    try {
      if (filename === clientURL) {
        res.writeHead(200, {
          "Content-Type": mime.contentType(path.basename(clientURL)),
          "Cache-Control": "no-cache, no-store, must-revalidate",
        })

        res.end(client.replace("SOCKET_ADDRESS", `"ws://${req.headers.host}"`))

        return
      }

      filename = path.resolve(path.join(config.dist, filename))

      if (await exists(filename)) {
        if ((await fs.lstat(filename)).isDirectory()) {
          filename = path.join(filename, "index.html")
        }
      } else {
        if (await exists(filename + ".html")) {
          filename += ".html"
        }
      }

      if (await exists(filename)) {
        handle(res, filename)
      } else {
        const file = path.join(config.dist, "404.html")

        res.writeHead(404)

        if (await exists(file)) {
          res.end(appendClient(await fs.readFile(file, "utf8")))
        } else {
          res.end(errorPage({ code: 404 }))
        }

        warn(`404 Not Found - ${req.url}`)
      }
    } catch (err) {
      res.writeHead(500, {
        "Content-Type": "text/html",
        "Cache-Control": "no-cache, no-store, must-revalidate",
      })

      res.end(
        errorPage({
          code: 500,
          error: err.stack,
          file: page?.meta,
        })
      )

      fail(`Couldn't serve ${req.url}`, err)
    }
  })

  // Increment port if the selected one is in use
  server.on("error", (err) => {
    if (err.code == "EADDRINUSE") {
      if (err.port < config.port + PORT_RETRY_LIMIT) {
        server.close()
        server.listen(++port)
      } else {
        fail(
          `Reached limit looking for open ports\n` +
            `Specify a \`port\` in your nightowl.js configuration`,
          err
        )

        throw new Error(err)
      }
    }
  })

  server.listen(port, () => {
    server.close()
    server.listen({ port, host }, () => {
      info(`Server running on http://localhost:${port}/`)
      wss = new WebSocketServer({ server })
    })
  })

  const send = (msg) => {
    if (wss) {
      wss.clients.forEach((client) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(msg)
        }
      })
    }
  }

  return {
    close: async () => {
      send("close")
      info("Closing server")
      await server.close()
      await wss?.close()
    },

    update: (urls = []) => {
      if (
        urls !== "all" &&
        urls.every(
          (url) =>
            url.endsWith(".css") ||
            (mime.contentType(path.basename(url)) &&
              mime.contentType(path.basename(url)).includes("image"))
        )
      ) {
        send(`assets.${urls.join()}`)
      } else {
        send("page")
      }
    },
  }
}
