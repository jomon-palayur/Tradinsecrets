import fs from "node:fs/promises"
import path from "node:path"
import chokidar from "chokidar"
import minimatch from "minimatch"

import config from "../config/index.js"
import build from "../build/index.js"

import { fail, info, time } from "../utils/logger.js"
import copy from "../utils/copy.js"
import Cache from "../utils/cache.js"

import { resetLayoutDependencies } from "../templates/layout.js"
import compile from "../templates/compile.js"
import render from "../templates/render.js"

import { restart } from "./worker.js"
import debounce from "./debounce.js"

const dependencyCache = new Cache()

// Determine whether a change has occured, and recompile affected templates
const handle = async (type, filename, templates) => {
  // Return early if this file will cause a restart
  if (config.watchAndRestart.some((rule) => minimatch(filename, rule))) {
    return { restart: true }
  }

  let needsRender = false
  let isDependency = false
  let urls = []

  // The file no longer exists. Note that rendered files aren't deleted.
  if (type === "unlink") {
    templates.remove(filename, templates)
    dependencyCache.delete(filename)
  }

  if (type === "change" || type === "add") {
    const toCompile = []

    // If the file is the data file, all files should be rendered
    if (config.data && filename === path.normalize(config.data)) {
      needsRender = true
    }

    // If this file is a template, add it to the list of files to compile
    if (config.isTemplate(filename)) {
      toCompile.push(filename)
    }

    // If this file is a dependency, add the dependant templates to the list
    const dependants = templates
      .list()
      .filter((template) => template.dependencies.includes(filename))

    if (dependants.length > 0) {
      const content = await fs.readFile(filename, "utf8")

      if (dependencyCache.changed(filename, content)) {
        toCompile.push(...dependants.map(({ filename }) => filename))

        resetLayoutDependencies(filename)
      }

      dependencyCache.set(filename, content)
      isDependency = true
    }

    // Copy files and add any returned URLs to the list
    const copiedFiles = await copy(filename)
    urls.push(...copiedFiles)

    // If the file being watched is located in the dist directory,
    // it was most likely added on purpose to force a manual reload
    if (minimatch(filename, config.dist)) urls.push(filename)

    // Compile the affected templates and append their URLs to the list
    if (toCompile.length > 0) {
      await time(`Compiling ${toCompile.length} files`, async () => {
        for (const filename of toCompile) {
          const template = await compile(
            filename,
            isDependency ? null : templates.changed
          )

          if (template) {
            needsRender = true

            templates.update(template)

            if (template.pages) {
              urls.push(...template.pages.map((page) => page.meta.url))
            }

            if (template.index) {
              urls.push(template.index.meta.url)
            }
          }
        }
      })
    }
  }

  return {
    render: needsRender,
    urls,
  }
}

// Before watching, run a build. This provides a dictionary of templates
// with methods to handle updates and removals.
// Template rendering is debounced, but file compilation happens in real-time.
export default (server = { update: () => {} }) =>
  build().then((templates) => {
    const delayUpdate = debounce(server.update, 50, true)
    const delayRender = debounce(render, 50, true)
    const delayInfo = debounce(info, 300)

    server.update()

    const onChange = async (filename, change) => {
      if (change.restart) {
        info(`${filename} has changed. Restarting...`)
        return restart()
      }

      if (change.render) {
        await delayRender(templates)
      }

      if (change.urls?.length > 0) {
        if (change.urls.length === 1) {
          info(`${filename} updated`)
        } else {
          info(`${filename} updated ${change.urls.length} files`)
        }

        delayUpdate(change.urls)
      } else {
        delayInfo("No change detected")
      }
    }

    const watcher = chokidar
      .watch([...config.watch, ...config.watchAndRestart], {
        ignoreInitial: true,
        awaitWriteFinish: true,
      })
      .on("all", (type, filename) => {
        handle(type, filename, templates)
          .then((change) => onChange(filename, change))
          .catch((error) => {
            fail(`Failed watching ${filename}`, error)
          })
      })

    return {
      close: async () => {
        info("Closing file watcher")
        await watcher.close()
      },
    }
  })
