import fs from "node:fs/promises"
import path from "node:path"
import esbuild from "esbuild"

import config from "../config/index.js"
import { warn, fail } from "./logger.js"
import { restart } from "../watch/worker.js"

let count = 0

// Use cache-busting to import a module, avoiding the cache
// Because Night Owl always uses the default export, try to return that
const reimport = (filename) =>
  import(filename + "?" + count++).then((lib) => {
    return lib.default ? lib.default : lib
  })

// With the `write` option set to false, return the compiled contents
// Otherwise, output the file to disk, and return the reimported module
// Clean up by removing the temporary file before completion
const build = (filename, options = {}) => {
  const outfile = path.join(
    config.tempDirectory,
    filename.replace(/\.[tj]sx?$/, ".js")
  )

  return esbuild
    .build({
      minify: process.env.NIGHTOWL_MODE === "build",
      ...options,
      entryPoints: [filename],
      bundle: true,
      outfile,
    })
    .then((result) => {
      if (options.write === false) {
        if (result.outputFiles.length > 1) {
          warn(
            `BUG: ${filename} produces more than one file`,
            `Only the first output file will be used`
          )
        }
        return result.outputFiles[0].text
      } else {
        const tmpfile = path.join(process.cwd(), outfile)

        return reimport(tmpfile).then(async (lib) => {
          await fs.rm(tmpfile)
          return lib
        })
      }
    })
}

export default (filename, hasDependencies = true, options) => {
  const ext = path.extname(filename)

  // Cache-busted imports are not garbage collected, so the worker
  // restarts after exceeding this threshold to contain memory use
  if (count > config.importThreshold) {
    warn("Restarting to reduce Night Owl's memory footprint")
    restart()
    return {}
  }

  // When an import has no dependencies, it doesn't need to be bundled
  if (!hasDependencies && ext === ".js") {
    return reimport(path.join(process.cwd(), filename))
  }

  options = {
    format: "esm",
    platform: "node",
    packages: "external",
    ...options,
  }

  return build(filename, options).catch((err) =>
    fail(`Failed to import ${filename}`, err)
  )
}

export const bundle = (filename, options) => {
  return build(filename, { ...options, write: false }).catch((err) =>
    fail(`Failed to bundle ${filename}`, err)
  )
}
